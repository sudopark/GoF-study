

## 1. 서론

객체지향 설계는 쉽지않다. 설계는 지금 당장 갖고 있는 문제를 해결할 수 있어야하지만, 나중에 생길 문제나 추가된 요구 사항들도 수용할 수 있도록 일반적이고 포괄적이어야 합니다. 즉 재설계를 하지 않아도 다시 사용할 수 있어야하고, 아니면 최소한의 수정을 통하여 다시 사용할 수 있는 설계여야 합니다.

- 책의 목적: 디자인 패턴이란 방식을 통해 소프트웨어 설계에서 얻은 세셋한 경험들을 기록해 두도록 하는것
- 입증된 기술을 디자인 패턴으로 정의해두면 새로운 시스템 개발자들은 디자인 패턴을 더 자주 유용하게 사용할수있다. 디자인 패턴은 설계자로 하여금 재사용이 가능한 설계를 선택하고, 재사용을 방해하는 설계는 배제하도록 도와줍니다.

### 1.1 디자인 패턴이란?

> 각 디자인 패턴은 기존 환경 내에서 반복적으로 일어나는 문제들을 설명한 후, 그 문제들에 대한 해법의 핵심을 설명해줍니다. 똑같은 방법으로 두번하지 않고 이 해법을 100만 번 이상 재사용할수 있도록 말이죠
>
> - 건축가 크리스토퍼 알렉산더

패턴을 구성하는 4가지 요소

1) **패턴 이름(pattern name):** 한 두 단어로 설계 문제와 해법을 서술, 설계에 이름을 부여하는 것은 설계 어휘를 늘리는 일이며 높은 수준의 추상화된 설계를 할수있게해줌
2) **문제(problem)**: 문제는 언제 패턴을 사용해야하는지 나타냄, 해결할 문제와 그 배경을 설명함.
3) **해법(solution)**: 설계를 구성하는 요소들과 그 요소들간의 관계, 책임, 그리고 협력 관계를 서술함(구체적인 설계나 구현을 설명 하지는 않음 -> 패턴은 다양한 케이스에 적용 가능한 템플릿이기 때문에), 구체적인 부분 대신에 디자인 패턴은 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해 클래스나 객체들의 나열 방법을 제공
4) **결과(consequence)**: 결과는 디자인 패턴을 적용해서 얻은 결과와 장단점을 서술함. 패턴을 선택하는 과정에서 또는 비용과 효과를 측정하는 단계에서 제일 중요한 부분. 소프트웨어의 결과란 시간, 공간, 언어 차이 등에 따라 달라짐. 재사용성은 객체지향 설계의 주요 요소이므로 패턴의 결과는 시스템의 유연성, 확장성, 이식성 등에 커다란 영향을 줌. 그래서 이런 설계들의 결과를 잘 정리해두면 평가에 도움

이책에서 이야기하는 디자인 패턴은 "특정한 전후관계에서 일반적 설계 문제를 해결하기 위해 상호교류하는 수정 가능한 객체와 클래스들에 대한 설명"

----

### 1.2 스몰토크 MVC를 사용한 디자인 패턴(생략)

-----

### 1.3 디자인 패턴 기술하기

이 책에서는 일정한 형태를 이용해서 디자인 패턴을 서술함, 각자의 패턴은 다음 템플릿에 따라 구분하여 정의됨

1. **패턴 이름과 분류(Pattern name and classification)**: 하나의 패턴에 붙은 이름은 그 자체가 핵심을 간결하게 전달함. 좋은 이름은 패턴의 생명

2. **의도(Intent)**: 이 디자인 패턴은 무엇을 하는것일까?에 대한 답을 나타냄. 혹은 의도와 논리적인 근거가 무엇일까요? 어떤 특정한 문제나 이슈를 해결하기 위한것일까?

3. **다른 이름(Also known as)**: 해당 패턴을 다르게 부르는 이름이 있다면 이를 표시

4. **동기(Motivation)**: 설계 문제를 제시하고 패턴 안에서 클래스나 객체 구조가 어떻게 문제를 해결하는지 설명해주는 일종의 시나리오

5. **활용성(Applicability)**: 해당 패턴을 어느 상황에 이용할수있을지를 나타냄. 혹은 패턴이 문제로 삼는 잘못된 설계의 예는 무엇일까? 이 상황을 어떻게 파악할 수 있을까

6. **구조(Structure)**: 객체 모델링 기법에 기반을 둔 표기법을 이용하여 해당 패턴에서 쓰는 클래스들을 시작적으로 나타냄. 또한 객체 사이에 오고가는 요청과 협력 관계의 순차를 표현하기 위해서 상호작용 다이어그램도 이용.

7. **참여자(Participant)**: 주어진 패턴을 구성하고 책임을 수행하는 클래스나 객체들을 설명

8. **협력 방법(Collaboration)**: 참여자들이 작업을 수행하기 위한 참여자들 간의 협력 관계를 정의

9. **결과(Consequence)**: 이 패턴이 자신의 목표를 어떻게 지원하는지, 패턴을 사용한 결과와 장단점을 표시

10. **구현(Implementation)**: 패턴을 구현할때 주의해야할점, 힌트, 함정 기법 등등

11. **예제 코드(Sample code)**

12. **잘 알려진 사용 예(Known use)**:실제 시스템에서 찾아볼 수 있는 패턴의 예시

13. **관련 패턴(Related pattern)**: 해당 패턴과 밀접하게 관련있는 다른 패턴, 이들의 차이점 및 각 상황별 패턴 선택 방식

------

### 1.4 디자인 패턴 카탈로그

해당 책에는 23개의 패턴을 소개

#### 추상 팩토리(Abstract Factory)

- 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴

#### 적응자(Adapter)

- 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로 호환성이 없는 인터페이스 때문에 함게 동작할 수 없는 클래스들이 함께 작동하도록해줌

#### 가교(Bridge)

- 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴

#### 빌더(Builder)

- 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴

#### 책임 연쇄(Chain of Repossibility)

- 요청을 처리할 수 있는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴

#### 명령(Command)

- 요청을 객체의 형태로 캡슐화하여 서로 요청이 다른 사용자의 매게변수화, 요청 저장 또는 로깅, 그리고 연산의 취소를 지원하게 만드는 패턴

#### 복합체(Composite)

- 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴. 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 함

#### 장식자(Decorator)

- 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴, **기능 확장이 필요할때 서브클래싱 대신 사용할 수 있는 유용한 대안**

#### 퍼사드(Facade)

- 서브 시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴

#### 팩토리 메서드(Factory method)

- 객체를 생성하는 인터페이스는 미리 정의하되, 인스턴스를 만들 클래스의 결정은 서브클래스 쪽에서 내리는 패턴 -> 인스턴스를 만드는 시점을 서브클래스로 미룸

#### 플라이급(Flyweight)

- 크기가 작은 객체가 여러 개 있을때 공유를 통해 이들을 효율적으로 지원하는것

#### 해석자(Interpretor)

- 주어진 언어에 대해 그 언어의 문접을 위한 표현 수단을 정의하고 이와 어울러 그 표현 수단을 사용해 언어로 작성된 문장을 해석하는 해석기를 정의

#### 반복자(Iterator)

- 내부 표현을 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴

#### 중재자(Mediator)

- 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴, 객체들이 직접 서로를 참조하지 않도록 함으로써 객체들간의 소결합(loose coupling)을 촉진시킴

#### 메멘토(Memento)

- 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화 시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올수 있도록 하는 패턴

#### 감시자(Observer)

- 객체 사이의 일대다 의존 관계를 정의해두어, 어떤 객체의 상태가 변할때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴

#### 원형(Prototype)

- 생성할 객체의 종류를 명세화하는데 원형이 되는 예시물을 이용하고 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴

#### 프록시(Proxy)

- 어떤 다른 객체로 접근하는것을 통제하기 위하여 그 객체의 대리자(surrogate) 또는 자리채움자(placeholder)를 제공하는 패턴

#### 단일체(Singleton)

- 어떤 클래스의 인스턴스는 오직 하나만 있음을 보장. 이에 접근할수있는 전역적인 접근점을 제공

#### 상태(State)

- 객체 내부의 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴 -> 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임

#### 전략(Strategy)

- 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하며 이들의 상호교환이 가능하도록 만드는 패턴. 알고리즘을 사용하는 사용자와 상관없이 독립젇으로 알고리즘을 다양하게 변경할수있게해줌

####  템플릿 메서드(Template method)

- 객체의 연산에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적인 처리는 서브클래스쪽으로 미룸

#### 방문자(Visitor)

- 객체 구조를 이루는 원소에 대해 수행할 연산을 포함하는 패턴, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게함

