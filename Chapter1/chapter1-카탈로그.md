### 1.5 카탈로그 조직화하기

- 패턴을 분류하는 두가지 방법

#### 1. 목적

: 카탈로그가 무엇을 하는지 정의 -> **생성**, **구조**, **행동** 중 한가지 목적을 지님

- 생성 패턴: 객체의 생성 과정에 관여

  -> 추상 팩토리 메소드, 팩토리, 빌더, 원형, 단일체

  => 생성 클래스 패턴은 객체 생성 **책임을 서브클래스로** 넘김 / 객체패턴에서는 이를 **다른 객체에게 넘김**

- 구조 패턴: 클래스나 객체 합성에 관여

  -> 적응자(class, object), 가교, 복합체, 장식자, 퍼사드, 플라이급, 프록시

  => 구조 클래스 패턴은 **상속을 이용한 클래스 복합**을 / 객체 패턴에서는 **객체를 합성**하는 방법을 기술

- 행동 패턴: 클래스나 객체들이 상호작용하는 방법과 책임을 분산

  -> 헤석자(class), 탬플릿메서드(class), 책임 연쇄, 명령, 해석자, 중재자, 메멘토, 감시자, 상태, 전략, 방문자

  => 클래스 패턴은 상속을 이용해 **알고리즘 제어흐름**을 기술 / 객체 패턴은 하나의 작업을 수행하기위해 객체 집합간 **협력**을 기술

#### 2. 범위

: 패턴을 클래스 혹은 객체에 적용할것인지 구분

- 클래스 패턴: 클래스와 서브클래스 간의 관련성을 다루는 패턴 -> 관련성은 주로 상속이며 컴파일 타임에 정적으로 결정됨
- 객체 패턴: 객체 관련성을 다룸, 런타임에서 결정되는 더 동적인 패턴



### 1.6 디자인 패턴을 이용하여 문제를 푸는 방법

#### 1. 적당한 객체 찾기

- 객체지향 설계의 어려운 부분은 시스템을 구성할 객체의 **분할**을 결정하는 -> 캡슐화, 크기 정하기, 종속성, 유연성, 성능, 진화, 재사용 등을 고려 하여야함

- 설계단계의 객체 대부분은 분석모델에 의하여 만들어지지만 이는 실제세계와 대응관계를 지니지 못할경우가 있다. 어떤 클래스는 높은수준의 추상화를 이루어 현제의 실세계를 반영할수는 있지만 미래의 실세계는 반영하기 힘듬 -> 설계 단계에서 만들어야하는 새로운 추상화는 설계의 유연성을 증진하기 위한 노력 중 하나

- 디자인 패턴은 덜 명확한 추상적 개념과 이것을 잡아낸 객체를 알아보는데 도움을줌

  -> ex) 전랙 패턴은 상호 교환 가능한 알고리즘을 어떻게 구현할지 설명 / 상태 패턴은 대상들의 각 상태를 객체로 표현

#### 2. 객체의 크기 결정

- 객체 크기는 매우 다양, 디자인 패턴은 이를 쉽게 도와줌

  -> ex) 퍼사드 패턴은 서브시스템을 어떻게 객체로 표현할 수 있을지를 나타냄 / 플라이급 패턴은 규모는 작지만 개수는 많은 객체를 다루는 패턴

- 혹은 더 작은 규모의 객체로 분할하는 구체적인 방법을 다룸

  -> ex) 추상 팩토리 패턴 및 빌더 패턴 -> 객체생성 책임만 다룸 / 방문자 패턴 및 명령패턴은 요청을 자신이 처리하지않고 다른 객체나 객체 집합이 요청을 처리하도록하여 책임을지게함

#### 3. 객체 인터페이스의 명세

- **시그니처**: 객체가 선언하는 모든 연산은 이름, 매개변수로 받아들이는 객체들, 리턴값을 명세
- **인터페이스**:  객체가 정의하는 모든 연산의 시그니처를 일컫는말
- **타입**: 특정 인터페이스를 나타낼때 사용하는 이름, 
- **상속**: 서브타입은 슈퍼타입의 인터페이스를 상속함 -> 서브타입은 슈퍼타입에 정의된 연산을 포함
- **동적 바인딩**: 객체지향에서 객체는 인터페이스로 자신을 노출함, 내부구현에 대한 정보는 제공 x -> 서로 다른 객체는 인터페이스에 구현된 요청의 구현 방법을 자유롭게 구현 가능 -> 런타임에 구현 객체를 연결짓는것
- **다형성**: 프로그래밍이 기대하는 객체를 동일한 인터페이스를 지니는 다른 객체로 대체할수있게해줌
- 디자인 패턴은 인터페이스에 정의되어야하는 중요 요소가 무엇이고, 어떤 종류의 데이터를 주고받아야하는지 식별하여 인터페이스를 정의하는것에 도움을줌 + 인터페이스간의 연관성도 정의함

#### 4. 객체 구현 명세하기

- 어떤 객체의 구현은 클래스에서 정의함. 클래스는 객체 내부의 데이터 표현 방법을 명세하고 수행할 연산을 정의함

- 객체는 클래스의 인스턴스를 만드는것에서부터 생성

- 클래스 상속(이미 정의된 객테의 구현을 바탕으로함 - 코드와 내부 표현 구조를 공유) / 인터페이스 상속(어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하는 메커니즘)

  - ex 책임 연쇄패턴) - 체인에 참여하는 객체들은 동일한 타입들만 지님

  - ex 복합체 패턴) - component 클래스는 공통의 인터페이스를 정의하고 composite 클래스는 공통의 구현을 정의
  - ex) 명령, 감시자, 상태, 전략 패턴은 순수 인터페이스인 추상클래스를 사용해 구현될때가 많음

#### 5. 구현에 따르지 않고 인터페이스에 따르는 프로그래밍

- 추상 클래스를 정의하고 인터페이스 개념으로 객체를 다룰때 얻을 수 있는 두가지 이점

  1. 사용자가 원하는 인터페이스를 그 객체가 만족하고있는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야할 필요가 없음
  2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상클래스가 무엇인지만 알면됨

  **-> 이를통해 서브시스템간의 구현 종속성이 사라짐.**

> 구현이 아닌 인터페이스에 따라 프로그래밍 합니다.

​		-> 어떤 변수(객체)를 구체 클래스의 인스턴스로 선언하는 일은 지양하고 인터페이스를 따르는 인스턴스 변수를 정의하는것이 이 책에 기술한 디자인 패턴의 일반적 방식이며 향태임

​	( 추상 팩토리, 빌더, 팩토리 메서드, 원형, 싱글턴 패턴은 구현체 클래스에서 인스턴스를 생성하도록 하고있지만 -> 객체 생성의 과정을 추상화 함으로써 인스턴스화할때 인터페이스와 구현을 연결하는 다른 방법을 제시)