

## 복합체 패턴 - 객체 구조



#### 의도

부분과 전체의 계층을 표현하기위해 객체들을 모아 트리구조를 구성, 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰수있도록 하는 패턴



#### 활용성

- 부분: 전체의 객체 **계통**을 표현하고 싶을때
- 사용자가 객체의 합성으로 생긴 객체와 개개의 객체 사이의 차이를 알지 않고도 자신의 일을 할수있음. 모든 객체를 똑같이 취급



#### 구조

- Component: 1)집합객체에서 정의될 모든 객체에 대한 인터페이스를 구현, 2)모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행동을 수현 3) 전체 클래스에 속한 요소들을 관리하는데 필요한 인터페이스를 정의 4) 순환구조에서 요소들을 포함하는 전체 클래스로 접근하는데 필요한 인터페이스를 정의 및 필요시 구현
- Leaf: 가장 말단의 객체(자식이 없음), 객체 합성에 가장 기본이 되는 객체의 행동을 정의
- Composite: 자식이 있는 구성요소에 대한 행동을 정의. 자신이 복합하는 요소들을 저장하면서 Componet 인터페이스에 정의된 자식관려누 연산을 구현
- Client: 인터페이스를 통해 복합구조 내의 객체들을 조작



#### 협력방법

- 사용자는 **복합구조 내의 객체간의 상호작용**을 위해 **component의 인터페이스**를 사용. leaf면 동작, composite면 자식에게 요청을 위임

  

#### 결과

- 기본 객체(leaf)와 복합 객체(composite)로 구성된 하나의 일관된 클래스 계통을 정의함, 사용자 코드는 일봐화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면 런타임 기본 객체와 복합객체를 구분하지않고 일관되게 프로그래밍할수있음
- 사용자 코득가 단순화됨
- 새로운 종류의 구성요소를 쉽게 추가할수있음
- 쉽게 추가 가능하다보니 지나치게 범용성을 많이 가짐 -> 컴파일레벨에서 구성요소 타입에 제약을 걸기가 힘들어짐



#### 구현

복합체 패턴을 구현할때 고려할사항

1. 포함 객체에 대한 명확한 참조자

   : 자식에서 부모를 참조 -> 구조를 거슬러 올라가거나 요소를 삭제하는 과정 등이 단순해짐

2. 구성요소 공유: 메모리 측면에서 우수하지만 제한사항 -> 플라이급 패턴

3. Component 인터페이스 최대화: 사용자가 leaf, composite 클래스가 존재하는지 모르게하는것이 주요 목표 -> Component는 leaf, composite에 정의된 모든 공통의 연산을 정의하고있어야합니다.

4. 자식을 관리하는 연산 선언: composite용 인터페이스를 component에 선언

   1) leaf에도 composite용 연산이 포함된다, leaf에서 이 연산들이 호출된다면 의미없는 행동을 하지 않도록 안전성 유지를 위한 비용을 지불해야함
   2) Composite 에서만 자식관리 관련 인터페이스를 정의한다면 사용단에서는 타입캐스팅을 해야한다.

   -> composite에만 필요한 인터페이스는 이곳에만 정의하고 component에는 getter를 선언



#### 관련 패턴

- 구성요소 - 부모간의 연결은 책임-연쇄 패턴에서 많이 사용
- 장식자패턴은 자주 복합체 패턴과 함께 사용 -> 이경우 둘다 동일한 부모 클래스를 상속받게됨
- 플라이급패턴
- 반복자 패턴을 이용하여 구성요소 순회
- 방문자 패턴을 사용하여 이 패턴을 사용하지않을때 composite와 leaf 클래스에 걸쳐 분산될수있는 행동을 극소화시킬수있음