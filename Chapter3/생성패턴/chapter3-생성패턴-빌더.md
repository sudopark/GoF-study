

### 빌더(Builder)

#### 의도

복잡한 객체를 생성하는 방법과, 표현하는 방법을 정의하는 클래스를 별도로 분리하여 서로 다른 표현이라도 이를 생성할 수 있는 **동일한 절차**를 제공할 수 있도록 함

#### 동기

예) RTF(Rich Text Format) 문서판독기에서 판독기는 RTF 포맷에서 다른 텍스트 포맷으로 포맷을 바꿀 수 있어야한다. 이때 가능한 문서 형식들 간의 변화 가능성에 제한이 없으며 판독기의 변경이 없이도 새로운 형태의 변환이 추가될 수 있어야함 -> 이를 위해 Reader와 convert를 분리하고 이들을 복합한다 가정

각 변환기(convert)들은 복잡한 객체를 생성하고 조립하는데 필요한 매커니즘을 converter 클래스에 정의된 인터페이스의 각 연산에서 구현

빌더 패턴은 이러한 경우에 사용 가능, 변환기 = 빌더, 리더 = 디렉터 / 이 예에서 빌더 패턴은 문서 포맷을 해석하는 알고리즘을 다른 형태로 어떻게 변환할것인가 결정하는 알고리즘과 분리함

#### 활용성

- 복합 개체의 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일때
- 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야할때

#### 참여자

- Builder: Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의
- ConcreteBuilder: 빌더 클래스에 정의된 인터페이스를 구현, 제품의 부품들을 모아 빌더를 복합. 생성할 요소들의 표현을 정의하고 관리. 또한 제품을 검색하는데 필요한 인터페이스를 제공
- Director: 빌더 인터페이스를 사용하는 객체를 합성
- Product:  생성할 복합 객체를 표현. ConcreteBuilder는 제품의 내부 표현을 구축하고 복합 객체가 어떻게 구성되는지에 대한 절차를 정의

#### 협력 방법

- 사용자는 director 객체를 생성하고 이렇게 만들어진 객체는 자신이 원하는 빌더 객체로 합성해 나감
- 제룸의 일부가 구축 될때마다 디렉터는 빌더에세 통보
- 빌더는 디렉터의 요청을 처리하여 제품에 부품을 추가
- 사용자는 빌더에서 제품을 검색

#### 결과

1. 제품에 대한 내부 표현을 다양하게 변화할 수 있음 -> 어떤 요소로 전체 제품을 복합하고 그 요소들이 어떤 타입으로 구현되었는지 알고있는 쪽은 빌더뿐 이기 때문에
2. 생성과 표현에 필요한 코드를 분리
3. 복합 객체를 생성하는 절차를 좀더 세밀하게 나눌 수 있음: 빌더 패턴은 디렉터의 통제 아래 하나씩 내부 구성요소들이 만들어지고 디렉터가 전체 복합 객체를 돌려 받기 전까지 복합 과정이 계속됨 -> 빌더 클래스의 인터페이스에는 제품을 생성하는 과정 자체가 반영되어있음

#### 구현

- 추상 클래스인 빌더 클래스에 디렉터가 요청하는 각각의 요소들을 생성하는 연산들을 정의(기본적으로 인터페이스만)

1. 조합에 필요한 인터페이스를 정의
2. 제품에 대한 추상 클래스는 필요 없는가 고려: 보통은 제품은 상세화된 빌더클래스의 서브 클래스로 생성되는데 제품마다 표현 방식이 다르고 공통점을 찾기 힘들끼 때문에 별 이득이 없음
3. 빌더에 있는 메서드에 대해서는 구현을 제공하지 않는것이 일반적 -> 서브클래스에서 필요한 매소드만 재정의

#### 잘 알려진 사용 예

- 컴파일러 서브시스템에 정의된 파서 클래스는 빌더 패턴에 정의된 디렉터에 해당하고 ProgramNodeBuilder 객테를 매개 변수로 받아 사용. 파서 객체는 구문 요소에 해당하는 대상을 발견할때마다 노드 빌더에 이를 통보하고 파싱이 끝나면 빌더에 파스트리를 만들어 달라고 + 결과를 사용자에게 반환할것을 요청
- ClassBuilder는 프로그램에 정의된 classes가 서브클래스들을 생성하기 위해 사용한 빌더. class는 디렉터 이기도 하고 프로덕트 이기도함

#### 관련 패턴

복합체를 생성해야할때 추상 팩토리 패턴은 빌더 패턴과 비슷한 모습을 보임. 근복적인 차이가 있다면 빌터 패턴은 복잡한 단계별 생성에 중점을 둔 반면 추상 팩토리 패턴은 제품의 유사군들이 존재할 때 유연한 설계에 중점을 두고있음.

빌더패턴은 생성 마지막 단계에서 생성한 제품을 반환하는 반면, 추상 팩토리 패턴에서는 만드는 즉시 제품이 반환됨